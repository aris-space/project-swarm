import numpy as np
from scipy.optimize import minimize
from single_agent_simulator.x.system_dynamics import simple_system_dynamics
from single_agent_simulator.x.ode_solver import rk4
from single_agent_controller.controllers.pid_ctrl import PID
from utils.constants2 import LLC_FREQ

# Define the simulation of the controller
def simulate_controller(params):
    kp_angle, kd_angle, kp_rate, kd_rate = params
    # Assume identical parameters for roll and pitch
    pid_params = {
        'abs': {'kp': kp_angle, 'ki': 0.0, 'kd': kd_angle},
        'rate': {'kp': kp_rate, 'ki': 0.0, 'kd': kd_rate}
    }

    # Simulation parameters
    dt = 1 / LLC_FREQ
    sim_time = 5.0  # Total simulation time in seconds
    time_steps = int(sim_time / dt)
    desired_angle = 0.0  # Desired steady-state angle

    # Initialize states
    angle = np.zeros(time_steps)
    rate = np.zeros(time_steps)

    # Initialize controllers
    angle_controller = PID(**pid_params['abs'])
    rate_controller = PID(**pid_params['rate'])

    for i in range(1, time_steps):
        # Angle error and control signal
        error_angle = desired_angle - angle[i - 1]
        desired_rate = angle_controller.update(desired_angle, angle[i - 1], dt)

        # Rate error and control signal
        error_rate = desired_rate - rate[i - 1]
        torque_command = rate_controller.update(desired_rate, rate[i - 1], dt)

        # Update states using RK4 integrator
        state = np.array([angle[i - 1], rate[i - 1]])
        state_new = rk4(simple_system_dynamics, state, torque_command, torque_command, LLC_FREQ)
        angle[i], rate[i] = state_new

    # Calculate performance metrics
    overshoot = np.max(np.abs(angle))
    settling_indices = np.where(np.abs(angle) < 0.02)[0]
    settling_time = settling_indices[0] * dt if settling_indices.size > 0 else sim_time

    # Define cost function (you can adjust weights as needed)
    cost = settling_time + overshoot * 10  # Weight overshoot more heavily

    return cost

# Objective function for optimization
def objective(params):
    return simulate_controller(params)

# Initial guess for [kp_angle, kd_angle, kp_rate, kd_rate]
initial_guess = [1.0, 0.1, 1.0, 0.1]

# Bounds for the parameters (you can adjust the ranges as needed)
bounds = [(0, 10), (0, 10), (0, 10), (0, 10)]

# Perform the optimization
result = minimize(objective, initial_guess, bounds=bounds, method='L-BFGS-B')

# Extract the optimal parameters
best_kp_angle, best_kd_angle, best_kp_rate, best_kd_rate = result.x

print(f"Optimal kp_angle: {best_kp_angle}")
print(f"Optimal kd_angle: {best_kd_angle}")
print(f"Optimal kp_rate: {best_kp_rate}")
print(f"Optimal kd_rate: {best_kd_rate}")